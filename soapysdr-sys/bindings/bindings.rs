/* automatically generated by rust-bindgen 0.66.1 */

pub const __bool_true_false_are_defined: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const SOAPY_SDR_TRUE: &[u8; 5] = b"true\0";
pub const SOAPY_SDR_FALSE: &[u8; 6] = b"false\0";
pub const SOAPY_SDR_TX: u32 = 0;
pub const SOAPY_SDR_RX: u32 = 1;
pub const SOAPY_SDR_END_BURST: u32 = 2;
pub const SOAPY_SDR_HAS_TIME: u32 = 4;
pub const SOAPY_SDR_END_ABRUPT: u32 = 8;
pub const SOAPY_SDR_ONE_PACKET: u32 = 16;
pub const SOAPY_SDR_MORE_FRAGMENTS: u32 = 32;
pub const SOAPY_SDR_WAIT_TRIGGER: u32 = 64;
pub const SOAPY_SDR_TIMEOUT: i32 = -1;
pub const SOAPY_SDR_STREAM_ERROR: i32 = -2;
pub const SOAPY_SDR_CORRUPTION: i32 = -3;
pub const SOAPY_SDR_OVERFLOW: i32 = -4;
pub const SOAPY_SDR_NOT_SUPPORTED: i32 = -5;
pub const SOAPY_SDR_TIME_ERROR: i32 = -6;
pub const SOAPY_SDR_UNDERFLOW: i32 = -7;
pub const SOAPY_SDR_CF64: &[u8; 5] = b"CF64\0";
pub const SOAPY_SDR_CF32: &[u8; 5] = b"CF32\0";
pub const SOAPY_SDR_CS32: &[u8; 5] = b"CS32\0";
pub const SOAPY_SDR_CU32: &[u8; 5] = b"CU32\0";
pub const SOAPY_SDR_CS16: &[u8; 5] = b"CS16\0";
pub const SOAPY_SDR_CU16: &[u8; 5] = b"CU16\0";
pub const SOAPY_SDR_CS12: &[u8; 5] = b"CS12\0";
pub const SOAPY_SDR_CU12: &[u8; 5] = b"CU12\0";
pub const SOAPY_SDR_CS8: &[u8; 4] = b"CS8\0";
pub const SOAPY_SDR_CU8: &[u8; 4] = b"CU8\0";
pub const SOAPY_SDR_CS4: &[u8; 4] = b"CS4\0";
pub const SOAPY_SDR_CU4: &[u8; 4] = b"CU4\0";
pub const SOAPY_SDR_F64: &[u8; 4] = b"F64\0";
pub const SOAPY_SDR_F32: &[u8; 4] = b"F32\0";
pub const SOAPY_SDR_S32: &[u8; 4] = b"S32\0";
pub const SOAPY_SDR_U32: &[u8; 4] = b"U32\0";
pub const SOAPY_SDR_S16: &[u8; 4] = b"S16\0";
pub const SOAPY_SDR_U16: &[u8; 4] = b"U16\0";
pub const SOAPY_SDR_S8: &[u8; 3] = b"S8\0";
pub const SOAPY_SDR_U8: &[u8; 3] = b"U8\0";
pub const SOAPY_SDR_API_VERSION: u32 = 524288;
pub const SOAPY_SDR_ABI_VERSION: &[u8; 4] = b"0.8\0";

#[doc = "! Definition for a min/max numeric range"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SoapySDRRange {
    pub minimum: f64,
    pub maximum: f64,
    pub step: f64,
}
#[test]
fn bindgen_test_layout_SoapySDRRange() {
    const UNINIT: ::std::mem::MaybeUninit<SoapySDRRange> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SoapySDRRange>(),
        24usize,
        concat!("Size of: ", stringify!(SoapySDRRange))
    );
    assert_eq!(
        ::std::mem::align_of::<SoapySDRRange>(),
        8usize,
        concat!("Alignment of ", stringify!(SoapySDRRange))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minimum) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SoapySDRRange),
            "::",
            stringify!(minimum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maximum) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SoapySDRRange),
            "::",
            stringify!(maximum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).step) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SoapySDRRange),
            "::",
            stringify!(step)
        )
    );
}
#[doc = "! Definition for a key/value string map"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SoapySDRKwargs {
    pub size: usize,
    pub keys: *mut *mut ::std::os::raw::c_char,
    pub vals: *mut *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_SoapySDRKwargs() {
    const UNINIT: ::std::mem::MaybeUninit<SoapySDRKwargs> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SoapySDRKwargs>(),
        24usize,
        concat!("Size of: ", stringify!(SoapySDRKwargs))
    );
    assert_eq!(
        ::std::mem::align_of::<SoapySDRKwargs>(),
        8usize,
        concat!("Alignment of ", stringify!(SoapySDRKwargs))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SoapySDRKwargs),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).keys) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SoapySDRKwargs),
            "::",
            stringify!(keys)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vals) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SoapySDRKwargs),
            "::",
            stringify!(vals)
        )
    );
}
extern "C" {
    #[doc = " Convert a markup string to a key-value map.\n The markup format is: \"key0=value0, key1=value1\""]
    pub fn SoapySDRKwargs_fromString(markup: *const ::std::os::raw::c_char) -> SoapySDRKwargs;
}
extern "C" {
    #[doc = " Convert a key-value map to a markup string.\n The markup format is: \"key0=value0, key1=value1\""]
    pub fn SoapySDRKwargs_toString(args: *const SoapySDRKwargs) -> *mut ::std::os::raw::c_char;
}
pub const SoapySDRArgInfoType_SOAPY_SDR_ARG_INFO_BOOL: SoapySDRArgInfoType = 0;
pub const SoapySDRArgInfoType_SOAPY_SDR_ARG_INFO_INT: SoapySDRArgInfoType = 1;
pub const SoapySDRArgInfoType_SOAPY_SDR_ARG_INFO_FLOAT: SoapySDRArgInfoType = 2;
pub const SoapySDRArgInfoType_SOAPY_SDR_ARG_INFO_STRING: SoapySDRArgInfoType = 3;
#[doc = "! Definition for argument info"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SoapySDRArgInfo {
    #[doc = "! The key used to identify the argument (required)"]
    pub key: *mut ::std::os::raw::c_char,
    #[doc = " The default value of the argument when not specified (required)\n Numbers should use standard floating point and integer formats.\n Boolean values should be represented as \"true\" and  \"false\"."]
    pub value: *mut ::std::os::raw::c_char,
    #[doc = "! The displayable name of the argument (optional, use key if empty)"]
    pub name: *mut ::std::os::raw::c_char,
    #[doc = "! A brief description about the argument (optional)"]
    pub description: *mut ::std::os::raw::c_char,
    #[doc = "! The units of the argument: dB, Hz, etc (optional)"]
    pub units: *mut ::std::os::raw::c_char,
    #[doc = "! The data type of the argument (required)"]
    pub type_: SoapySDRArgInfoType,
    #[doc = " The range of possible numeric values (optional)\n When specified, the argument should be restricted to this range.\n The range is only applicable to numeric argument types."]
    pub range: SoapySDRRange,
    #[doc = "! The size of the options set, or 0 when not used."]
    pub numOptions: usize,
    #[doc = " A discrete list of possible values (optional)\n When specified, the argument should be restricted to this options set."]
    pub options: *mut *mut ::std::os::raw::c_char,
    #[doc = " A discrete list of displayable names for the enumerated options (optional)\n When not specified, the option value itself can be used as a display name."]
    pub optionNames: *mut *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_SoapySDRArgInfo() {
    const UNINIT: ::std::mem::MaybeUninit<SoapySDRArgInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SoapySDRArgInfo>(),
        96usize,
        concat!("Size of: ", stringify!(SoapySDRArgInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<SoapySDRArgInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(SoapySDRArgInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SoapySDRArgInfo),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SoapySDRArgInfo),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SoapySDRArgInfo),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).description) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SoapySDRArgInfo),
            "::",
            stringify!(description)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).units) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SoapySDRArgInfo),
            "::",
            stringify!(units)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SoapySDRArgInfo),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).range) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SoapySDRArgInfo),
            "::",
            stringify!(range)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numOptions) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(SoapySDRArgInfo),
            "::",
            stringify!(numOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).options) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(SoapySDRArgInfo),
            "::",
            stringify!(options)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).optionNames) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(SoapySDRArgInfo),
            "::",
            stringify!(optionNames)
        )
    );
}
extern "C" {
    #[doc = " Free a pointer allocated by SoapySDR.\n For most platforms this is a simple call around free()"]
    pub fn SoapySDR_free(ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Clear the contents of a list of string\n Convenience call to deal with results that return a string list."]
    pub fn SoapySDRStrings_clear(elems: *mut *mut *mut ::std::os::raw::c_char, length: usize);
}
extern "C" {
    #[doc = " Set a key/value pair in a kwargs structure.\n \\post\n If the key exists, the existing entry will be modified;\n otherwise a new entry will be appended to args.\n On error, the elements of args will not be modified,\n and args is guaranteed to be in a good state.\n \\return 0 for success, otherwise allocation error"]
    pub fn SoapySDRKwargs_set(
        args: *mut SoapySDRKwargs,
        key: *const ::std::os::raw::c_char,
        val: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get a value given a key in a kwargs structure.\n \\return the string or NULL if not found"]
    pub fn SoapySDRKwargs_get(
        args: *const SoapySDRKwargs,
        key: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Clear the contents of a kwargs structure.\n This frees all the underlying memory and clears the members."]
    pub fn SoapySDRKwargs_clear(args: *mut SoapySDRKwargs);
}
extern "C" {
    #[doc = " Clear a list of kwargs structures.\n This frees all the underlying memory and clears the members."]
    pub fn SoapySDRKwargsList_clear(args: *mut SoapySDRKwargs, length: usize);
}
extern "C" {
    #[doc = " Clear the contents of a argument info structure.\n This frees all the underlying memory and clears the members."]
    pub fn SoapySDRArgInfo_clear(info: *mut SoapySDRArgInfo);
}
extern "C" {
    #[doc = " Clear a list of argument info structures.\n This frees all the underlying memory and clears the members."]
    pub fn SoapySDRArgInfoList_clear(info: *mut SoapySDRArgInfo, length: usize);
}
extern "C" {
    #[doc = " Convert a error code to a string for printing purposes.\n If the error code is unrecognized, errToStr returns \"UNKNOWN\".\n \\param errorCode a negative integer return code\n \\return a pointer to a string representing the error"]
    pub fn SoapySDR_errToStr(errorCode: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SoapySDRDevice {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SoapySDRStream {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Get the last status code after a Device API call.\n The status code is cleared on entry to each Device call.\n When an device API call throws, the C bindings catch\n the exception, and set a non-zero last status code.\n Use lastStatus() to determine success/failure for\n Device calls without integer status return codes."]
    pub fn SoapySDRDevice_lastStatus() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the last error message after a device call fails.\n When an device API call throws, the C bindings catch\n the exception, store its message in thread-safe storage,\n and return a non-zero status code to indicate failure.\n Use lastError() to access the exception's error message."]
    pub fn SoapySDRDevice_lastError() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Enumerate a list of available devices on the system.\n \\param args device construction key/value argument filters\n \\param [out] length the number of elements in the result.\n \\return a list of arguments strings, each unique to a device"]
    pub fn SoapySDRDevice_enumerate(
        args: *const SoapySDRKwargs,
        length: *mut usize,
    ) -> *mut SoapySDRKwargs;
}
extern "C" {
    #[doc = " Enumerate a list of available devices on the system.\n Markup format for args: \"keyA=valA, keyB=valB\".\n \\param args a markup string of key/value argument filters\n \\param [out] length the number of elements in the result.\n \\return a list of arguments strings, each unique to a device"]
    pub fn SoapySDRDevice_enumerateStrArgs(
        args: *const ::std::os::raw::c_char,
        length: *mut usize,
    ) -> *mut SoapySDRKwargs;
}
extern "C" {
    #[doc = " Make a new Device object given device construction args.\n The device pointer will be stored in a table so subsequent calls\n with the same arguments will produce the same device.\n For every call to make, there should be a matched call to unmake.\n\n \\param args device construction key/value argument map\n \\return a pointer to a new Device object"]
    pub fn SoapySDRDevice_make(args: *const SoapySDRKwargs) -> *mut SoapySDRDevice;
}
extern "C" {
    #[doc = " Make a new Device object given device construction args.\n The device pointer will be stored in a table so subsequent calls\n with the same arguments will produce the same device.\n For every call to make, there should be a matched call to unmake.\n\n \\param args a markup string of key/value arguments\n \\return a pointer to a new Device object or null for error"]
    pub fn SoapySDRDevice_makeStrArgs(args: *const ::std::os::raw::c_char) -> *mut SoapySDRDevice;
}
extern "C" {
    #[doc = " Unmake or release a device object handle.\n\n \\param device a pointer to a device object\n \\return 0 for success or error code on failure"]
    pub fn SoapySDRDevice_unmake(device: *mut SoapySDRDevice) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Create a list of devices from a list of construction arguments.\n This is a convenience call to parallelize device construction,\n and is fundamentally a parallel for loop of make(Kwargs).\n\n \\param argsList a list of device arguments per each device\n \\param length the length of the argsList array\n \\return a list of device pointers per each specified argument"]
    pub fn SoapySDRDevice_make_list(
        argsList: *const SoapySDRKwargs,
        length: usize,
    ) -> *mut *mut SoapySDRDevice;
}
extern "C" {
    #[doc = " Create a list of devices from a list of construction arguments.\n This is a convenience call to parallelize device construction,\n and is fundamentally a parallel for loop of makeStrArgs(args).\n\n \\param argsList a list of device arguments per each device\n \\param length the length of the argsList array\n \\return a list of device pointers per each specified argument"]
    pub fn SoapySDRDevice_make_listStrArgs(
        argsList: *const *const ::std::os::raw::c_char,
        length: usize,
    ) -> *mut *mut SoapySDRDevice;
}
extern "C" {
    #[doc = " Unmake or release a list of device handles\n and free the devices array memory as well.\n This is a convenience call to parallelize device destruction,\n and is fundamentally a parallel for loop of unmake(Device *).\n\n \\param devices a list of pointers to device objects\n \\param length the length of the devices array\n \\return 0 for success or error code on failure"]
    pub fn SoapySDRDevice_unmake_list(
        devices: *mut *mut SoapySDRDevice,
        length: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " A key that uniquely identifies the device driver.\n This key identifies the underlying implementation.\n Several variants of a product may share a driver.\n \\param device a pointer to a device instance"]
    pub fn SoapySDRDevice_getDriverKey(
        device: *const SoapySDRDevice,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " A key that uniquely identifies the hardware.\n This key should be meaningful to the user\n to optimize for the underlying hardware.\n \\param device a pointer to a device instance"]
    pub fn SoapySDRDevice_getHardwareKey(
        device: *const SoapySDRDevice,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Query a dictionary of available device information.\n This dictionary can any number of values like\n vendor name, product name, revisions, serials...\n This information can be displayed to the user\n to help identify the instantiated device.\n \\param device a pointer to a device instance"]
    pub fn SoapySDRDevice_getHardwareInfo(device: *const SoapySDRDevice) -> SoapySDRKwargs;
}
extern "C" {
    #[doc = " Set the frontend mapping of available DSP units to RF frontends.\n This mapping controls channel mapping and channel availability.\n \\param device a pointer to a device instance\n \\param direction the channel direction RX or TX\n \\param mapping a vendor-specific mapping string\n \\return an error code or 0 for success"]
    pub fn SoapySDRDevice_setFrontendMapping(
        device: *mut SoapySDRDevice,
        direction: ::std::os::raw::c_int,
        mapping: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the mapping configuration string.\n \\param device a pointer to a device instance\n \\param direction the channel direction RX or TX\n \\return the vendor-specific mapping string"]
    pub fn SoapySDRDevice_getFrontendMapping(
        device: *const SoapySDRDevice,
        direction: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get a number of channels given the streaming direction\n \\param device a pointer to a device instance\n \\param direction the channel direction RX or TX\n \\return the number of channels"]
    pub fn SoapySDRDevice_getNumChannels(
        device: *const SoapySDRDevice,
        direction: ::std::os::raw::c_int,
    ) -> usize;
}
extern "C" {
    #[doc = " Get channel info given the streaming direction\n \\param device a pointer to a device instance\n \\param direction the channel direction RX or TX\n \\param channel the channel number to get info for\n \\return channel information"]
    pub fn SoapySDRDevice_getChannelInfo(
        device: *const SoapySDRDevice,
        direction: ::std::os::raw::c_int,
        channel: usize,
    ) -> SoapySDRKwargs;
}
extern "C" {
    #[doc = " Find out if the specified channel is full or half duplex.\n \\param device a pointer to a device instance\n \\param direction the channel direction RX or TX\n \\param channel an available channel on the device\n \\return true for full duplex, false for half duplex"]
    pub fn SoapySDRDevice_getFullDuplex(
        device: *const SoapySDRDevice,
        direction: ::std::os::raw::c_int,
        channel: usize,
    ) -> bool;
}
extern "C" {
    #[doc = " Query a list of the available stream formats.\n \\param device a pointer to a device instance\n \\param direction the channel direction RX or TX\n \\param channel an available channel on the device\n \\param [out] length the number of format strings\n \\return a list of allowed format strings.\n  See SoapySDRDevice_setupStream() for the format syntax."]
    pub fn SoapySDRDevice_getStreamFormats(
        device: *const SoapySDRDevice,
        direction: ::std::os::raw::c_int,
        channel: usize,
        length: *mut usize,
    ) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the hardware's native stream format for this channel.\n This is the format used by the underlying transport layer,\n and the direct buffer access API calls (when available).\n \\param device a pointer to a device instance\n \\param direction the channel direction RX or TX\n \\param channel an available channel on the device\n \\param [out] fullScale the maximum possible value\n \\return the native stream buffer format string"]
    pub fn SoapySDRDevice_getNativeStreamFormat(
        device: *const SoapySDRDevice,
        direction: ::std::os::raw::c_int,
        channel: usize,
        fullScale: *mut f64,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Query the argument info description for stream args.\n \\param device a pointer to a device instance\n \\param direction the channel direction RX or TX\n \\param channel an available channel on the device\n \\param [out] length the number of argument infos\n \\return a list of argument info structures"]
    pub fn SoapySDRDevice_getStreamArgsInfo(
        device: *const SoapySDRDevice,
        direction: ::std::os::raw::c_int,
        channel: usize,
        length: *mut usize,
    ) -> *mut SoapySDRArgInfo;
}
extern "C" {
    #[doc = " Close an open stream created by setupStream\n \\param device a pointer to a device instance\n \\param stream the opaque pointer to a stream handle\n \\return 0 for success or error code on failure"]
    pub fn SoapySDRDevice_closeStream(
        device: *mut SoapySDRDevice,
        stream: *mut SoapySDRStream,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the stream's maximum transmission unit (MTU) in number of elements.\n The MTU specifies the maximum payload transfer in a stream operation.\n This value can be used as a stream buffer allocation size that can\n best optimize throughput given the underlying stream implementation.\n\n \\param device a pointer to a device instance\n \\param stream the opaque pointer to a stream handle\n \\return the MTU in number of stream elements (never zero)"]
    pub fn SoapySDRDevice_getStreamMTU(
        device: *const SoapySDRDevice,
        stream: *mut SoapySDRStream,
    ) -> usize;
}
extern "C" {
    #[doc = " Activate a stream.\n Call activate to prepare a stream before using read/write().\n The implementation control switches or stimulate data flow.\n\n The timeNs is only valid when the flags have SOAPY_SDR_HAS_TIME.\n The numElems count can be used to request a finite burst size.\n The SOAPY_SDR_END_BURST flag can signal end on the finite burst.\n Not all implementations will support the full range of options.\n In this case, the implementation returns SOAPY_SDR_NOT_SUPPORTED.\n\n \\param device a pointer to a device instance\n \\param stream the opaque pointer to a stream handle\n \\param flags optional flag indicators about the stream\n \\param timeNs optional activation time in nanoseconds\n \\param numElems optional element count for burst control\n \\return 0 for success or error code on failure"]
    pub fn SoapySDRDevice_activateStream(
        device: *mut SoapySDRDevice,
        stream: *mut SoapySDRStream,
        flags: ::std::os::raw::c_int,
        timeNs: ::std::os::raw::c_longlong,
        numElems: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Deactivate a stream.\n Call deactivate when not using using read/write().\n The implementation control switches or halt data flow.\n\n The timeNs is only valid when the flags have SOAPY_SDR_HAS_TIME.\n Not all implementations will support the full range of options.\n In this case, the implementation returns SOAPY_SDR_NOT_SUPPORTED.\n\n \\param device a pointer to a device instance\n \\param stream the opaque pointer to a stream handle\n \\param flags optional flag indicators about the stream\n \\param timeNs optional deactivation time in nanoseconds\n \\return 0 for success or error code on failure"]
    pub fn SoapySDRDevice_deactivateStream(
        device: *mut SoapySDRDevice,
        stream: *mut SoapySDRStream,
        flags: ::std::os::raw::c_int,
        timeNs: ::std::os::raw::c_longlong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read elements from a stream for reception.\n This is a multi-channel call, and buffs should be an array of void *,\n where each pointer will be filled with data from a different channel.\n\n **Client code compatibility:**\n The readStream() call should be well defined at all times,\n including prior to activation and after deactivation.\n When inactive, readStream() should implement the timeout\n specified by the caller and return SOAPY_SDR_TIMEOUT.\n\n \\param device a pointer to a device instance\n \\param stream the opaque pointer to a stream handle\n \\param buffs an array of void* buffers num chans in size\n \\param numElems the number of elements in each buffer\n \\param [out] flags optional flag indicators about the result\n \\param [out] timeNs the buffer's timestamp in nanoseconds\n \\param timeoutUs the timeout in microseconds\n \\return the number of elements read per buffer or error code"]
    pub fn SoapySDRDevice_readStream(
        device: *mut SoapySDRDevice,
        stream: *mut SoapySDRStream,
        buffs: *const *mut ::std::os::raw::c_void,
        numElems: usize,
        flags: *mut ::std::os::raw::c_int,
        timeNs: *mut ::std::os::raw::c_longlong,
        timeoutUs: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Write elements to a stream for transmission.\n This is a multi-channel call, and buffs should be an array of void *,\n where each pointer will be filled with data for a different channel.\n\n **Client code compatibility:**\n Client code relies on writeStream() for proper back-pressure.\n The writeStream() implementation must enforce the timeout\n such that the call blocks until space becomes available\n or timeout expiration.\n\n \\param device a pointer to a device instance\n \\param stream the opaque pointer to a stream handle\n \\param buffs an array of void* buffers num chans in size\n \\param numElems the number of elements in each buffer\n \\param [in,out] flags optional input flags and output flags\n \\param timeNs the buffer's timestamp in nanoseconds\n \\param timeoutUs the timeout in microseconds\n \\return the number of elements written per buffer or error"]
    pub fn SoapySDRDevice_writeStream(
        device: *mut SoapySDRDevice,
        stream: *mut SoapySDRStream,
        buffs: *const *const ::std::os::raw::c_void,
        numElems: usize,
        flags: *mut ::std::os::raw::c_int,
        timeNs: ::std::os::raw::c_longlong,
        timeoutUs: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Readback status information about a stream.\n This call is typically used on a transmit stream\n to report time errors, underflows, and burst completion.\n\n **Client code compatibility:**\n Client code may continually poll readStreamStatus() in a loop.\n Implementations of readStreamStatus() should wait in the call\n for a status change event or until the timeout expiration.\n When stream status is not implemented on a particular stream,\n readStreamStatus() should return SOAPY_SDR_NOT_SUPPORTED.\n Client code may use this indication to disable a polling loop.\n\n \\param device a pointer to a device instance\n \\param stream the opaque pointer to a stream handle\n \\param chanMask to which channels this status applies\n \\param flags optional input flags and output flags\n \\param timeNs the buffer's timestamp in nanoseconds\n \\param timeoutUs the timeout in microseconds\n \\return 0 for success or error code like timeout"]
    pub fn SoapySDRDevice_readStreamStatus(
        device: *mut SoapySDRDevice,
        stream: *mut SoapySDRStream,
        chanMask: *mut usize,
        flags: *mut ::std::os::raw::c_int,
        timeNs: *mut ::std::os::raw::c_longlong,
        timeoutUs: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " How many direct access buffers can the stream provide?\n This is the number of times the user can call acquire()\n on a stream without making subsequent calls to release().\n A return value of 0 means that direct access is not supported.\n\n \\param device a pointer to a device instance\n \\param stream the opaque pointer to a stream handle\n \\return the number of direct access buffers or 0"]
    pub fn SoapySDRDevice_getNumDirectAccessBuffers(
        device: *mut SoapySDRDevice,
        stream: *mut SoapySDRStream,
    ) -> usize;
}
extern "C" {
    #[doc = " Get the buffer addresses for a scatter/gather table entry.\n When the underlying DMA implementation uses scatter/gather\n then this call provides the user addresses for that table.\n\n Example: The caller may query the DMA memory addresses once\n after stream creation to pre-allocate a re-usable ring-buffer.\n\n \\param device a pointer to a device instance\n \\param stream the opaque pointer to a stream handle\n \\param handle an index value between 0 and num direct buffers - 1\n \\param buffs an array of void* buffers num chans in size\n \\return 0 for success or error code when not supported"]
    pub fn SoapySDRDevice_getDirectAccessBufferAddrs(
        device: *mut SoapySDRDevice,
        stream: *mut SoapySDRStream,
        handle: usize,
        buffs: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Acquire direct buffers from a receive stream.\n This call is part of the direct buffer access API.\n\n The buffs array will be filled with a stream pointer for each channel.\n Each pointer can be read up to the number of return value elements.\n\n The handle will be set by the implementation so that the caller\n may later release access to the buffers with releaseReadBuffer().\n Handle represents an index into the internal scatter/gather table\n such that handle is between 0 and num direct buffers - 1.\n\n \\param device a pointer to a device instance\n \\param stream the opaque pointer to a stream handle\n \\param handle an index value used in the release() call\n \\param buffs an array of void* buffers num chans in size\n \\param flags optional flag indicators about the result\n \\param timeNs the buffer's timestamp in nanoseconds\n \\param timeoutUs the timeout in microseconds\n \\return the number of elements read per buffer or error code"]
    pub fn SoapySDRDevice_acquireReadBuffer(
        device: *mut SoapySDRDevice,
        stream: *mut SoapySDRStream,
        handle: *mut usize,
        buffs: *mut *const ::std::os::raw::c_void,
        flags: *mut ::std::os::raw::c_int,
        timeNs: *mut ::std::os::raw::c_longlong,
        timeoutUs: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Release an acquired buffer back to the receive stream.\n This call is part of the direct buffer access API.\n\n \\param device a pointer to a device instance\n \\param stream the opaque pointer to a stream handle\n \\param handle the opaque handle from the acquire() call"]
    pub fn SoapySDRDevice_releaseReadBuffer(
        device: *mut SoapySDRDevice,
        stream: *mut SoapySDRStream,
        handle: usize,
    );
}
extern "C" {
    #[doc = " Acquire direct buffers from a transmit stream.\n This call is part of the direct buffer access API.\n\n The buffs array will be filled with a stream pointer for each channel.\n Each pointer can be written up to the number of return value elements.\n\n The handle will be set by the implementation so that the caller\n may later release access to the buffers with releaseWriteBuffer().\n Handle represents an index into the internal scatter/gather table\n such that handle is between 0 and num direct buffers - 1.\n\n \\param device a pointer to a device instance\n \\param stream the opaque pointer to a stream handle\n \\param handle an index value used in the release() call\n \\param buffs an array of void* buffers num chans in size\n \\param timeoutUs the timeout in microseconds\n \\return the number of available elements per buffer or error"]
    pub fn SoapySDRDevice_acquireWriteBuffer(
        device: *mut SoapySDRDevice,
        stream: *mut SoapySDRStream,
        handle: *mut usize,
        buffs: *mut *mut ::std::os::raw::c_void,
        timeoutUs: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Release an acquired buffer back to the transmit stream.\n This call is part of the direct buffer access API.\n\n Stream meta-data is provided as part of the release call,\n and not the acquire call so that the caller may acquire\n buffers without committing to the contents of the meta-data,\n which can be determined by the user as the buffers are filled.\n\n \\param device a pointer to a device instance\n \\param stream the opaque pointer to a stream handle\n \\param handle the opaque handle from the acquire() call\n \\param numElems the number of elements written to each buffer\n \\param flags optional input flags and output flags\n \\param timeNs the buffer's timestamp in nanoseconds"]
    pub fn SoapySDRDevice_releaseWriteBuffer(
        device: *mut SoapySDRDevice,
        stream: *mut SoapySDRStream,
        handle: usize,
        numElems: usize,
        flags: *mut ::std::os::raw::c_int,
        timeNs: ::std::os::raw::c_longlong,
    );
}
extern "C" {
    #[doc = " Get a list of available antennas to select on a given chain.\n \\param device a pointer to a device instance\n \\param direction the channel direction RX or TX\n \\param channel an available channel on the device\n \\param [out] length the number of antenna names\n \\return a list of available antenna names"]
    pub fn SoapySDRDevice_listAntennas(
        device: *const SoapySDRDevice,
        direction: ::std::os::raw::c_int,
        channel: usize,
        length: *mut usize,
    ) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Set the selected antenna on a chain.\n \\param device a pointer to a device instance\n \\param direction the channel direction RX or TX\n \\param channel an available channel on the device\n \\param name the name of an available antenna\n \\return an error code or 0 for success"]
    pub fn SoapySDRDevice_setAntenna(
        device: *mut SoapySDRDevice,
        direction: ::std::os::raw::c_int,
        channel: usize,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the selected antenna on a chain.\n \\param device a pointer to a device instance\n \\param direction the channel direction RX or TX\n \\param channel an available channel on the device\n \\return the name of an available antenna"]
    pub fn SoapySDRDevice_getAntenna(
        device: *const SoapySDRDevice,
        direction: ::std::os::raw::c_int,
        channel: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Does the device support automatic DC offset corrections?\n \\param device a pointer to a device instance\n \\param direction the channel direction RX or TX\n \\param channel an available channel on the device\n \\return true if automatic corrections are supported"]
    pub fn SoapySDRDevice_hasDCOffsetMode(
        device: *const SoapySDRDevice,
        direction: ::std::os::raw::c_int,
        channel: usize,
    ) -> bool;
}
extern "C" {
    #[doc = " Set the automatic DC offset corrections mode.\n \\param device a pointer to a device instance\n \\param direction the channel direction RX or TX\n \\param channel an available channel on the device\n \\param automatic true for automatic offset correction\n \\return an error code or 0 for success"]
    pub fn SoapySDRDevice_setDCOffsetMode(
        device: *mut SoapySDRDevice,
        direction: ::std::os::raw::c_int,
        channel: usize,
        automatic: bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the automatic DC offset corrections mode.\n \\param device a pointer to a device instance\n \\param direction the channel direction RX or TX\n \\param channel an available channel on the device\n \\return true for automatic offset correction"]
    pub fn SoapySDRDevice_getDCOffsetMode(
        device: *const SoapySDRDevice,
        direction: ::std::os::raw::c_int,
        channel: usize,
    ) -> bool;
}
extern "C" {
    #[doc = " Does the device support frontend DC offset correction?\n \\param device a pointer to a device instance\n \\param direction the channel direction RX or TX\n \\param channel an available channel on the device\n \\return true if DC offset corrections are supported"]
    pub fn SoapySDRDevice_hasDCOffset(
        device: *const SoapySDRDevice,
        direction: ::std::os::raw::c_int,
        channel: usize,
    ) -> bool;
}
extern "C" {
    #[doc = " Set the frontend DC offset correction.\n \\param device a pointer to a device instance\n \\param direction the channel direction RX or TX\n \\param channel an available channel on the device\n \\param offsetI the relative correction (1.0 max)\n \\param offsetQ the relative correction (1.0 max)\n \\return an error code or 0 for success"]
    pub fn SoapySDRDevice_setDCOffset(
        device: *mut SoapySDRDevice,
        direction: ::std::os::raw::c_int,
        channel: usize,
        offsetI: f64,
        offsetQ: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the frontend DC offset correction.\n \\param device a pointer to a device instance\n \\param direction the channel direction RX or TX\n \\param channel an available channel on the device\n \\param [out] offsetI the relative correction (1.0 max)\n \\param [out] offsetQ the relative correction (1.0 max)\n \\return 0 for success or error code on failure"]
    pub fn SoapySDRDevice_getDCOffset(
        device: *const SoapySDRDevice,
        direction: ::std::os::raw::c_int,
        channel: usize,
        offsetI: *mut f64,
        offsetQ: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Does the device support frontend IQ balance correction?\n \\param device a pointer to a device instance\n \\param direction the channel direction RX or TX\n \\param channel an available channel on the device\n \\return true if IQ balance corrections are supported"]
    pub fn SoapySDRDevice_hasIQBalance(
        device: *const SoapySDRDevice,
        direction: ::std::os::raw::c_int,
        channel: usize,
    ) -> bool;
}
extern "C" {
    #[doc = " Set the frontend IQ balance correction.\n \\param device a pointer to a device instance\n \\param direction the channel direction RX or TX\n \\param channel an available channel on the device\n \\param balanceI the relative correction (1.0 max)\n \\param balanceQ the relative correction (1.0 max)\n \\return an error code or 0 for success"]
    pub fn SoapySDRDevice_setIQBalance(
        device: *mut SoapySDRDevice,
        direction: ::std::os::raw::c_int,
        channel: usize,
        balanceI: f64,
        balanceQ: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the frontend IQ balance correction.\n \\param device a pointer to a device instance\n \\param direction the channel direction RX or TX\n \\param channel an available channel on the device\n \\param [out] balanceI the relative correction (1.0 max)\n \\param [out] balanceQ the relative correction (1.0 max)\n \\return 0 for success or error code on failure"]
    pub fn SoapySDRDevice_getIQBalance(
        device: *const SoapySDRDevice,
        direction: ::std::os::raw::c_int,
        channel: usize,
        balanceI: *mut f64,
        balanceQ: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Does the device support automatic frontend IQ balance correction?\n \\param device a pointer to a device instance\n \\param direction the channel direction RX or TX\n \\param channel an available channel on the device\n \\return true if automatic IQ balance corrections are supported"]
    pub fn SoapySDRDevice_hasIQBalanceMode(
        device: *const SoapySDRDevice,
        direction: ::std::os::raw::c_int,
        channel: usize,
    ) -> bool;
}
extern "C" {
    #[doc = " Set the automatic frontend IQ balance correction.\n \\param device a pointer to a device instance\n \\param direction the channel direction RX or TX\n \\param channel an available channel on the device\n \\param automatic true for automatic correction\n \\return 0 for success or error code on failure"]
    pub fn SoapySDRDevice_setIQBalanceMode(
        device: *mut SoapySDRDevice,
        direction: ::std::os::raw::c_int,
        channel: usize,
        automatic: bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the automatic frontend IQ balance corrections mode.\n \\param device a pointer to a device instance\n \\param direction the channel direction RX or TX\n \\param channel an available channel on the device\n \\return true for automatic correction"]
    pub fn SoapySDRDevice_getIQBalanceMode(
        device: *const SoapySDRDevice,
        direction: ::std::os::raw::c_int,
        channel: usize,
    ) -> bool;
}
extern "C" {
    #[doc = " Does the device support frontend frequency correction?\n \\param device a pointer to a device instance\n \\param direction the channel direction RX or TX\n \\param channel an available channel on the device\n \\return true if frequency corrections are supported"]
    pub fn SoapySDRDevice_hasFrequencyCorrection(
        device: *const SoapySDRDevice,
        direction: ::std::os::raw::c_int,
        channel: usize,
    ) -> bool;
}
extern "C" {
    #[doc = " Fine tune the frontend frequency correction.\n \\param device a pointer to a device instance\n \\param direction the channel direction RX or TX\n \\param channel an available channel on the device\n \\param value the correction in PPM\n \\return an error code or 0 for success"]
    pub fn SoapySDRDevice_setFrequencyCorrection(
        device: *mut SoapySDRDevice,
        direction: ::std::os::raw::c_int,
        channel: usize,
        value: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the frontend frequency correction value.\n \\param device a pointer to a device instance\n \\param direction the channel direction RX or TX\n \\param channel an available channel on the device\n \\return the correction value in PPM"]
    pub fn SoapySDRDevice_getFrequencyCorrection(
        device: *const SoapySDRDevice,
        direction: ::std::os::raw::c_int,
        channel: usize,
    ) -> f64;
}
extern "C" {
    #[doc = " List available amplification elements.\n Elements should be in order RF to baseband.\n \\param device a pointer to a device instance\n \\param direction the channel direction RX or TX\n \\param channel an available channel\n \\param [out] length the number of gain names\n \\return a list of gain string names"]
    pub fn SoapySDRDevice_listGains(
        device: *const SoapySDRDevice,
        direction: ::std::os::raw::c_int,
        channel: usize,
        length: *mut usize,
    ) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Does the device support automatic gain control?\n \\param device a pointer to a device instance\n \\param direction the channel direction RX or TX\n \\param channel an available channel on the device\n \\return true for automatic gain control"]
    pub fn SoapySDRDevice_hasGainMode(
        device: *const SoapySDRDevice,
        direction: ::std::os::raw::c_int,
        channel: usize,
    ) -> bool;
}
extern "C" {
    #[doc = " Set the automatic gain mode on the chain.\n \\param device a pointer to a device instance\n \\param direction the channel direction RX or TX\n \\param channel an available channel on the device\n \\param automatic true for automatic gain setting\n \\return an error code or 0 for success"]
    pub fn SoapySDRDevice_setGainMode(
        device: *mut SoapySDRDevice,
        direction: ::std::os::raw::c_int,
        channel: usize,
        automatic: bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the automatic gain mode on the chain.\n \\param device a pointer to a device instance\n \\param direction the channel direction RX or TX\n \\param channel an available channel on the device\n \\return true for automatic gain setting"]
    pub fn SoapySDRDevice_getGainMode(
        device: *const SoapySDRDevice,
        direction: ::std::os::raw::c_int,
        channel: usize,
    ) -> bool;
}
extern "C" {
    #[doc = " Set the overall amplification in a chain.\n The gain will be distributed automatically across available element.\n \\param device a pointer to a device instance\n \\param direction the channel direction RX or TX\n \\param channel an available channel on the device\n \\param value the new amplification value in dB\n \\return an error code or 0 for success"]
    pub fn SoapySDRDevice_setGain(
        device: *mut SoapySDRDevice,
        direction: ::std::os::raw::c_int,
        channel: usize,
        value: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the value of a amplification element in a chain.\n \\param device a pointer to a device instance\n \\param direction the channel direction RX or TX\n \\param channel an available channel on the device\n \\param name the name of an amplification element\n \\param value the new amplification value in dB\n \\return an error code or 0 for success"]
    pub fn SoapySDRDevice_setGainElement(
        device: *mut SoapySDRDevice,
        direction: ::std::os::raw::c_int,
        channel: usize,
        name: *const ::std::os::raw::c_char,
        value: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the overall value of the gain elements in a chain.\n \\param device a pointer to a device instance\n \\param direction the channel direction RX or TX\n \\param channel an available channel on the device\n \\return the value of the gain in dB"]
    pub fn SoapySDRDevice_getGain(
        device: *const SoapySDRDevice,
        direction: ::std::os::raw::c_int,
        channel: usize,
    ) -> f64;
}
extern "C" {
    #[doc = " Get the value of an individual amplification element in a chain.\n \\param device a pointer to a device instance\n \\param direction the channel direction RX or TX\n \\param channel an available channel on the device\n \\param name the name of an amplification element\n \\return the value of the gain in dB"]
    pub fn SoapySDRDevice_getGainElement(
        device: *const SoapySDRDevice,
        direction: ::std::os::raw::c_int,
        channel: usize,
        name: *const ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    #[doc = " Get the overall range of possible gain values.\n \\param device a pointer to a device instance\n \\param direction the channel direction RX or TX\n \\param channel an available channel on the device\n \\return the range of possible gain values for this channel in dB"]
    pub fn SoapySDRDevice_getGainRange(
        device: *const SoapySDRDevice,
        direction: ::std::os::raw::c_int,
        channel: usize,
    ) -> SoapySDRRange;
}
extern "C" {
    #[doc = " Get the range of possible gain values for a specific element.\n \\param device a pointer to a device instance\n \\param direction the channel direction RX or TX\n \\param channel an available channel on the device\n \\param name the name of an amplification element\n \\return the range of possible gain values for the specified amplification element in dB"]
    pub fn SoapySDRDevice_getGainElementRange(
        device: *const SoapySDRDevice,
        direction: ::std::os::raw::c_int,
        channel: usize,
        name: *const ::std::os::raw::c_char,
    ) -> SoapySDRRange;
}
extern "C" {
    #[doc = " Set the center frequency of the chain.\n  - For RX, this specifies the down-conversion frequency.\n  - For TX, this specifies the up-conversion frequency.\n\n The default implementation of setFrequency() will tune the \"RF\"\n component as close as possible to the requested center frequency.\n Tuning inaccuracies will be compensated for with the \"BB\" component.\n\n The args can be used to augment the tuning algorithm.\n  - Use \"OFFSET\" to specify an \"RF\" tuning offset,\n    usually with the intention of moving the LO out of the passband.\n    The offset will be compensated for using the \"BB\" component.\n  - Use the name of a component for the key and a frequency in Hz\n    as the value (any format) to enforce a specific frequency.\n    The other components will be tuned with compensation\n    to achieve the specified overall frequency.\n  - Use the name of a component for the key and the value \"IGNORE\"\n    so that the tuning algorithm will avoid altering the component.\n  - Vendor specific implementations can also use the same args to augment\n    tuning in other ways such as specifying fractional vs integer N tuning.\n\n \\param device a pointer to a device instance\n \\param direction the channel direction RX or TX\n \\param channel an available channel on the device\n \\param frequency the center frequency in Hz\n \\param args optional tuner arguments\n \\return an error code or 0 for success"]
    pub fn SoapySDRDevice_setFrequency(
        device: *mut SoapySDRDevice,
        direction: ::std::os::raw::c_int,
        channel: usize,
        frequency: f64,
        args: *const SoapySDRKwargs,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Tune the center frequency of the specified element.\n  - For RX, this specifies the down-conversion frequency.\n  - For TX, this specifies the up-conversion frequency.\n\n Recommended names used to represent tunable components:\n  - \"CORR\" - freq error correction in PPM\n  - \"RF\" - frequency of the RF frontend\n  - \"BB\" - frequency of the baseband DSP\n\n \\param device a pointer to a device instance\n \\param direction the channel direction RX or TX\n \\param channel an available channel on the device\n \\param name the name of a tunable element\n \\param frequency the center frequency in Hz\n \\param args optional tuner arguments\n \\return an error code or 0 for success"]
    pub fn SoapySDRDevice_setFrequencyComponent(
        device: *mut SoapySDRDevice,
        direction: ::std::os::raw::c_int,
        channel: usize,
        name: *const ::std::os::raw::c_char,
        frequency: f64,
        args: *const SoapySDRKwargs,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the overall center frequency of the chain.\n  - For RX, this specifies the down-conversion frequency.\n  - For TX, this specifies the up-conversion frequency.\n \\param device a pointer to a device instance\n \\param direction the channel direction RX or TX\n \\param channel an available channel on the device\n \\return the center frequency in Hz"]
    pub fn SoapySDRDevice_getFrequency(
        device: *const SoapySDRDevice,
        direction: ::std::os::raw::c_int,
        channel: usize,
    ) -> f64;
}
extern "C" {
    #[doc = " Get the frequency of a tunable element in the chain.\n \\param device a pointer to a device instance\n \\param direction the channel direction RX or TX\n \\param channel an available channel on the device\n \\param name the name of a tunable element\n \\return the tunable element's frequency in Hz"]
    pub fn SoapySDRDevice_getFrequencyComponent(
        device: *const SoapySDRDevice,
        direction: ::std::os::raw::c_int,
        channel: usize,
        name: *const ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    #[doc = " List available tunable elements in the chain.\n Elements should be in order RF to baseband.\n \\param device a pointer to a device instance\n \\param direction the channel direction RX or TX\n \\param channel an available channel\n \\param [out] length the number names\n \\return a list of tunable elements by name"]
    pub fn SoapySDRDevice_listFrequencies(
        device: *const SoapySDRDevice,
        direction: ::std::os::raw::c_int,
        channel: usize,
        length: *mut usize,
    ) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the range of overall frequency values.\n \\param device a pointer to a device instance\n \\param direction the channel direction RX or TX\n \\param channel an available channel on the device\n \\param [out] length the number of ranges\n \\return a list of frequency ranges in Hz"]
    pub fn SoapySDRDevice_getFrequencyRange(
        device: *const SoapySDRDevice,
        direction: ::std::os::raw::c_int,
        channel: usize,
        length: *mut usize,
    ) -> *mut SoapySDRRange;
}
extern "C" {
    #[doc = " Get the range of tunable values for the specified element.\n \\param device a pointer to a device instance\n \\param direction the channel direction RX or TX\n \\param channel an available channel on the device\n \\param name the name of a tunable element\n \\param [out] length the number of ranges\n \\return a list of frequency ranges in Hz"]
    pub fn SoapySDRDevice_getFrequencyRangeComponent(
        device: *const SoapySDRDevice,
        direction: ::std::os::raw::c_int,
        channel: usize,
        name: *const ::std::os::raw::c_char,
        length: *mut usize,
    ) -> *mut SoapySDRRange;
}
extern "C" {
    #[doc = " Query the argument info description for tune args.\n \\param device a pointer to a device instance\n \\param direction the channel direction RX or TX\n \\param channel an available channel on the device\n \\param [out] length the number of argument infos\n \\return a list of argument info structures"]
    pub fn SoapySDRDevice_getFrequencyArgsInfo(
        device: *const SoapySDRDevice,
        direction: ::std::os::raw::c_int,
        channel: usize,
        length: *mut usize,
    ) -> *mut SoapySDRArgInfo;
}
extern "C" {
    #[doc = " Set the baseband sample rate of the chain.\n \\param device a pointer to a device instance\n \\param direction the channel direction RX or TX\n \\param channel an available channel on the device\n \\param rate the sample rate in samples per second\n \\return an error code or 0 for success"]
    pub fn SoapySDRDevice_setSampleRate(
        device: *mut SoapySDRDevice,
        direction: ::std::os::raw::c_int,
        channel: usize,
        rate: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the baseband sample rate of the chain.\n \\param device a pointer to a device instance\n \\param direction the channel direction RX or TX\n \\param channel an available channel on the device\n \\return the sample rate in samples per second"]
    pub fn SoapySDRDevice_getSampleRate(
        device: *const SoapySDRDevice,
        direction: ::std::os::raw::c_int,
        channel: usize,
    ) -> f64;
}
extern "C" {
    #[doc = " Get the range of possible baseband sample rates.\n \\deprecated replaced by getSampleRateRange()\n \\param device a pointer to a device instance\n \\param direction the channel direction RX or TX\n \\param channel an available channel on the device\n \\param [out] length the number of sample rates\n \\return a list of possible rates in samples per second"]
    pub fn SoapySDRDevice_listSampleRates(
        device: *const SoapySDRDevice,
        direction: ::std::os::raw::c_int,
        channel: usize,
        length: *mut usize,
    ) -> *mut f64;
}
extern "C" {
    #[doc = " Get the range of possible baseband sample rates.\n \\param device a pointer to a device instance\n \\param direction the channel direction RX or TX\n \\param channel an available channel on the device\n \\param [out] length the number of sample rates\n \\return a list of sample rate ranges in samples per second"]
    pub fn SoapySDRDevice_getSampleRateRange(
        device: *const SoapySDRDevice,
        direction: ::std::os::raw::c_int,
        channel: usize,
        length: *mut usize,
    ) -> *mut SoapySDRRange;
}
extern "C" {
    #[doc = " Set the baseband filter width of the chain.\n \\param device a pointer to a device instance\n \\param direction the channel direction RX or TX\n \\param channel an available channel on the device\n \\param bw the baseband filter width in Hz\n \\return an error code or 0 for success"]
    pub fn SoapySDRDevice_setBandwidth(
        device: *mut SoapySDRDevice,
        direction: ::std::os::raw::c_int,
        channel: usize,
        bw: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the baseband filter width of the chain.\n \\param device a pointer to a device instance\n \\param direction the channel direction RX or TX\n \\param channel an available channel on the device\n \\return the baseband filter width in Hz"]
    pub fn SoapySDRDevice_getBandwidth(
        device: *const SoapySDRDevice,
        direction: ::std::os::raw::c_int,
        channel: usize,
    ) -> f64;
}
extern "C" {
    #[doc = " Get the range of possible baseband filter widths.\n \\deprecated replaced by getBandwidthRange()\n \\param device a pointer to a device instance\n \\param direction the channel direction RX or TX\n \\param channel an available channel on the device\n \\param [out] length the number of bandwidths\n \\return a list of possible bandwidths in Hz"]
    pub fn SoapySDRDevice_listBandwidths(
        device: *const SoapySDRDevice,
        direction: ::std::os::raw::c_int,
        channel: usize,
        length: *mut usize,
    ) -> *mut f64;
}
extern "C" {
    #[doc = " Get the range of possible baseband filter widths.\n \\param device a pointer to a device instance\n \\param direction the channel direction RX or TX\n \\param channel an available channel on the device\n \\param [out] length the number of ranges\n \\return a list of bandwidth ranges in Hz"]
    pub fn SoapySDRDevice_getBandwidthRange(
        device: *const SoapySDRDevice,
        direction: ::std::os::raw::c_int,
        channel: usize,
        length: *mut usize,
    ) -> *mut SoapySDRRange;
}
extern "C" {
    #[doc = " Set the master clock rate of the device.\n \\param device a pointer to a device instance\n \\param rate the clock rate in Hz\n \\return an error code or 0 for success"]
    pub fn SoapySDRDevice_setMasterClockRate(
        device: *mut SoapySDRDevice,
        rate: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the master clock rate of the device.\n \\param device a pointer to a device instance\n \\return the clock rate in Hz"]
    pub fn SoapySDRDevice_getMasterClockRate(device: *const SoapySDRDevice) -> f64;
}
extern "C" {
    #[doc = " Get the range of available master clock rates.\n \\param device a pointer to a device instance\n \\param [out] length the number of ranges\n \\return a list of clock rate ranges in Hz"]
    pub fn SoapySDRDevice_getMasterClockRates(
        device: *const SoapySDRDevice,
        length: *mut usize,
    ) -> *mut SoapySDRRange;
}
extern "C" {
    #[doc = " Set the reference clock rate of the device.\n \\param device a pointer to a device instance\n \\param rate the clock rate in Hz\n \\return an error code or 0 for success"]
    pub fn SoapySDRDevice_setReferenceClockRate(
        device: *mut SoapySDRDevice,
        rate: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the reference clock rate of the device.\n \\param device a pointer to a device instance\n \\return the clock rate in Hz"]
    pub fn SoapySDRDevice_getReferenceClockRate(device: *const SoapySDRDevice) -> f64;
}
extern "C" {
    #[doc = " Get the range of available reference clock rates.\n \\param device a pointer to a device instance\n \\param [out] length the number of sources\n \\return a list of clock rate ranges in Hz"]
    pub fn SoapySDRDevice_getReferenceClockRates(
        device: *const SoapySDRDevice,
        length: *mut usize,
    ) -> *mut SoapySDRRange;
}
extern "C" {
    #[doc = " Get the list of available clock sources.\n \\param device a pointer to a device instance\n \\param [out] length the number of sources\n \\return a list of clock source names"]
    pub fn SoapySDRDevice_listClockSources(
        device: *const SoapySDRDevice,
        length: *mut usize,
    ) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Set the clock source on the device\n \\param device a pointer to a device instance\n \\param source the name of a clock source\n \\return an error code or 0 for success"]
    pub fn SoapySDRDevice_setClockSource(
        device: *mut SoapySDRDevice,
        source: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the clock source of the device\n \\param device a pointer to a device instance\n \\return the name of a clock source"]
    pub fn SoapySDRDevice_getClockSource(
        device: *const SoapySDRDevice,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the list of available time sources.\n \\param device a pointer to a device instance\n \\param [out] length the number of sources\n \\return a list of time source names"]
    pub fn SoapySDRDevice_listTimeSources(
        device: *const SoapySDRDevice,
        length: *mut usize,
    ) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Set the time source on the device\n \\param device a pointer to a device instance\n \\param source the name of a time source\n \\return an error code or 0 for success"]
    pub fn SoapySDRDevice_setTimeSource(
        device: *mut SoapySDRDevice,
        source: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the time source of the device\n \\param device a pointer to a device instance\n \\return the name of a time source"]
    pub fn SoapySDRDevice_getTimeSource(
        device: *const SoapySDRDevice,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Does this device have a hardware clock?\n \\param device a pointer to a device instance\n \\param what optional argument\n \\return true if the hardware clock exists"]
    pub fn SoapySDRDevice_hasHardwareTime(
        device: *const SoapySDRDevice,
        what: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " Read the time from the hardware clock on the device.\n The what argument can refer to a specific time counter.\n \\param device a pointer to a device instance\n \\param what optional argument\n \\return the time in nanoseconds"]
    pub fn SoapySDRDevice_getHardwareTime(
        device: *const SoapySDRDevice,
        what: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " Write the time to the hardware clock on the device.\n The what argument can refer to a specific time counter.\n \\param device a pointer to a device instance\n \\param timeNs time in nanoseconds\n \\param what optional argument\n \\return 0 for success or error code on failure"]
    pub fn SoapySDRDevice_setHardwareTime(
        device: *mut SoapySDRDevice,
        timeNs: ::std::os::raw::c_longlong,
        what: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the time of subsequent configuration calls.\n The what argument can refer to a specific command queue.\n Implementations may use a time of 0 to clear.\n \\deprecated replaced by setHardwareTime()\n \\param device a pointer to a device instance\n \\param timeNs time in nanoseconds\n \\param what optional argument\n \\return 0 for success or error code on failure"]
    pub fn SoapySDRDevice_setCommandTime(
        device: *mut SoapySDRDevice,
        timeNs: ::std::os::raw::c_longlong,
        what: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " List the available global readback sensors.\n A sensor can represent a reference lock, RSSI, temperature.\n \\param device a pointer to a device instance\n \\param [out] length the number of sensor names\n \\return a list of available sensor string names"]
    pub fn SoapySDRDevice_listSensors(
        device: *const SoapySDRDevice,
        length: *mut usize,
    ) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get meta-information about a sensor.\n Example: displayable name, type, range.\n \\param device a pointer to a device instance\n \\param key the ID name of an available sensor\n \\return meta-information about a sensor"]
    pub fn SoapySDRDevice_getSensorInfo(
        device: *const SoapySDRDevice,
        key: *const ::std::os::raw::c_char,
    ) -> SoapySDRArgInfo;
}
extern "C" {
    #[doc = " Readback a global sensor given the name.\n The value returned is a string which can represent\n a boolean (\"true\"/\"false\"), an integer, or float.\n \\param device a pointer to a device instance\n \\param key the ID name of an available sensor\n \\return the current value of the sensor"]
    pub fn SoapySDRDevice_readSensor(
        device: *const SoapySDRDevice,
        key: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " List the available channel readback sensors.\n A sensor can represent a reference lock, RSSI, temperature.\n \\param device a pointer to a device instance\n \\param direction the channel direction RX or TX\n \\param channel an available channel on the device\n \\param [out] length the number of sensor names\n \\return a list of available sensor string names"]
    pub fn SoapySDRDevice_listChannelSensors(
        device: *const SoapySDRDevice,
        direction: ::std::os::raw::c_int,
        channel: usize,
        length: *mut usize,
    ) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get meta-information about a channel sensor.\n Example: displayable name, type, range.\n \\param device a pointer to a device instance\n \\param direction the channel direction RX or TX\n \\param channel an available channel on the device\n \\param key the ID name of an available sensor\n \\return meta-information about a sensor"]
    pub fn SoapySDRDevice_getChannelSensorInfo(
        device: *const SoapySDRDevice,
        direction: ::std::os::raw::c_int,
        channel: usize,
        key: *const ::std::os::raw::c_char,
    ) -> SoapySDRArgInfo;
}
extern "C" {
    #[doc = " Readback a channel sensor given the name.\n The value returned is a string which can represent\n a boolean (\"true\"/\"false\"), an integer, or float.\n \\param device a pointer to a device instance\n \\param direction the channel direction RX or TX\n \\param channel an available channel on the device\n \\param key the ID name of an available sensor\n \\return the current value of the sensor"]
    pub fn SoapySDRDevice_readChannelSensor(
        device: *const SoapySDRDevice,
        direction: ::std::os::raw::c_int,
        channel: usize,
        key: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get a list of available register interfaces by name.\n \\param device a pointer to a device instance\n \\param [out] length the number of interfaces\n \\return a list of available register interfaces"]
    pub fn SoapySDRDevice_listRegisterInterfaces(
        device: *const SoapySDRDevice,
        length: *mut usize,
    ) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Write a register on the device given the interface name.\n This can represent a register on a soft CPU, FPGA, IC;\n the interpretation is up the implementation to decide.\n \\param device a pointer to a device instance\n \\param name the name of a available register interface\n \\param addr the register address\n \\param value the register value\n \\return 0 for success or error code on failure"]
    pub fn SoapySDRDevice_writeRegister(
        device: *mut SoapySDRDevice,
        name: *const ::std::os::raw::c_char,
        addr: ::std::os::raw::c_uint,
        value: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read a register on the device given the interface name.\n \\param device a pointer to a device instance\n \\param name the name of a available register interface\n \\param addr the register address\n \\return the register value"]
    pub fn SoapySDRDevice_readRegister(
        device: *const SoapySDRDevice,
        name: *const ::std::os::raw::c_char,
        addr: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Write a memory block on the device given the interface name.\n This can represent a memory block on a soft CPU, FPGA, IC;\n the interpretation is up the implementation to decide.\n \\param device a pointer to a device instance\n \\param name the name of a available memory block interface\n \\param addr the memory block start address\n \\param value the memory block content\n \\param length the number of words in the block\n \\return 0 for success or error code on failure"]
    pub fn SoapySDRDevice_writeRegisters(
        device: *mut SoapySDRDevice,
        name: *const ::std::os::raw::c_char,
        addr: ::std::os::raw::c_uint,
        value: *const ::std::os::raw::c_uint,
        length: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read a memory block on the device given the interface name.\n Pass the number of words to be read in via length;\n length will be set to the number of actual words read.\n \\param device a pointer to a device instance\n \\param name the name of a available memory block interface\n \\param addr the memory block start address\n \\param [inout] length number of words to be read from memory block\n \\return the memory block content"]
    pub fn SoapySDRDevice_readRegisters(
        device: *const SoapySDRDevice,
        name: *const ::std::os::raw::c_char,
        addr: ::std::os::raw::c_uint,
        length: *mut usize,
    ) -> *mut ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Describe the allowed keys and values used for settings.\n \\param device a pointer to a device instance\n \\param [out] length the number of sensor names\n \\return a list of argument info structures"]
    pub fn SoapySDRDevice_getSettingInfo(
        device: *const SoapySDRDevice,
        length: *mut usize,
    ) -> *mut SoapySDRArgInfo;
}
extern "C" {
    #[doc = " Write an arbitrary setting on the device.\n The interpretation is up the implementation.\n \\param device a pointer to a device instance\n \\param key the setting identifier\n \\param value the setting value\n \\return 0 for success or error code on failure"]
    pub fn SoapySDRDevice_writeSetting(
        device: *mut SoapySDRDevice,
        key: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read an arbitrary setting on the device.\n \\param device a pointer to a device instance\n \\param key the setting identifier\n \\return the setting value"]
    pub fn SoapySDRDevice_readSetting(
        device: *const SoapySDRDevice,
        key: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Describe the allowed keys and values used for channel settings.\n \\param device a pointer to a device instance\n \\param direction the channel direction RX or TX\n \\param channel an available channel on the device\n \\param [out] length the number of sensor names\n \\return a list of argument info structures"]
    pub fn SoapySDRDevice_getChannelSettingInfo(
        device: *const SoapySDRDevice,
        direction: ::std::os::raw::c_int,
        channel: usize,
        length: *mut usize,
    ) -> *mut SoapySDRArgInfo;
}
extern "C" {
    #[doc = " Write an arbitrary channel setting on the device.\n The interpretation is up the implementation.\n \\param device a pointer to a device instance\n \\param direction the channel direction RX or TX\n \\param channel an available channel on the device\n \\param key the setting identifier\n \\param value the setting value\n \\return 0 for success or error code on failure"]
    pub fn SoapySDRDevice_writeChannelSetting(
        device: *mut SoapySDRDevice,
        direction: ::std::os::raw::c_int,
        channel: usize,
        key: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read an arbitrary channel setting on the device.\n \\param device a pointer to a device instance\n \\param direction the channel direction RX or TX\n \\param channel an available channel on the device\n \\param key the setting identifier\n \\return the setting value"]
    pub fn SoapySDRDevice_readChannelSetting(
        device: *const SoapySDRDevice,
        direction: ::std::os::raw::c_int,
        channel: usize,
        key: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get a list of available GPIO banks by name.\n \\param [out] length the number of GPIO banks\n \\param device a pointer to a device instance"]
    pub fn SoapySDRDevice_listGPIOBanks(
        device: *const SoapySDRDevice,
        length: *mut usize,
    ) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Write the value of a GPIO bank.\n \\param device a pointer to a device instance\n \\param bank the name of an available bank\n \\param value an integer representing GPIO bits\n \\return 0 for success or error code on failure"]
    pub fn SoapySDRDevice_writeGPIO(
        device: *mut SoapySDRDevice,
        bank: *const ::std::os::raw::c_char,
        value: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Write the value of a GPIO bank with modification mask.\n \\param device a pointer to a device instance\n \\param bank the name of an available bank\n \\param value an integer representing GPIO bits\n \\param mask a modification mask where 1 = modify\n \\return 0 for success or error code on failure"]
    pub fn SoapySDRDevice_writeGPIOMasked(
        device: *mut SoapySDRDevice,
        bank: *const ::std::os::raw::c_char,
        value: ::std::os::raw::c_uint,
        mask: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Readback the value of a GPIO bank.\n \\param device a pointer to a device instance\n \\param bank the name of an available bank\n \\return an integer representing GPIO bits"]
    pub fn SoapySDRDevice_readGPIO(
        device: *const SoapySDRDevice,
        bank: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Write the data direction of a GPIO bank.\n 1 bits represent outputs, 0 bits represent inputs.\n \\param device a pointer to a device instance\n \\param bank the name of an available bank\n \\param dir an integer representing data direction bits\n \\return 0 for success or error code on failure"]
    pub fn SoapySDRDevice_writeGPIODir(
        device: *mut SoapySDRDevice,
        bank: *const ::std::os::raw::c_char,
        dir: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Write the data direction of a GPIO bank with modification mask.\n 1 bits represent outputs, 0 bits represent inputs.\n \\param device a pointer to a device instance\n \\param bank the name of an available bank\n \\param dir an integer representing data direction bits\n \\param mask a modification mask where 1 = modify\n \\return 0 for success or error code on failure"]
    pub fn SoapySDRDevice_writeGPIODirMasked(
        device: *mut SoapySDRDevice,
        bank: *const ::std::os::raw::c_char,
        dir: ::std::os::raw::c_uint,
        mask: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read the data direction of a GPIO bank.\n \\param device a pointer to a device instance\n 1 bits represent outputs, 0 bits represent inputs.\n \\param bank the name of an available bank\n \\return an integer representing data direction bits"]
    pub fn SoapySDRDevice_readGPIODir(
        device: *const SoapySDRDevice,
        bank: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Write to an available I2C slave.\n If the device contains multiple I2C masters,\n the address bits can encode which master.\n \\param device a pointer to a device instance\n \\param addr the address of the slave\n \\param data an array of bytes write out\n \\param numBytes the number of bytes to write\n \\return 0 for success or error code on failure"]
    pub fn SoapySDRDevice_writeI2C(
        device: *mut SoapySDRDevice,
        addr: ::std::os::raw::c_int,
        data: *const ::std::os::raw::c_char,
        numBytes: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read from an available I2C slave.\n If the device contains multiple I2C masters,\n the address bits can encode which master.\n Pass the number of bytes to be read in via numBytes;\n numBytes will be set to the number of actual bytes read.\n \\param device a pointer to a device instance\n \\param addr the address of the slave\n \\param [inout] numBytes the number of bytes to read\n \\return an array of bytes read from the slave"]
    pub fn SoapySDRDevice_readI2C(
        device: *mut SoapySDRDevice,
        addr: ::std::os::raw::c_int,
        numBytes: *mut usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Perform a SPI transaction and return the result.\n Its up to the implementation to set the clock rate,\n and read edge, and the write edge of the SPI core.\n SPI slaves without a readback pin will return 0.\n\n If the device contains multiple SPI masters,\n the address bits can encode which master.\n\n \\param device a pointer to a device instance\n \\param addr an address of an available SPI slave\n \\param data the SPI data, numBits-1 is first out\n \\param numBits the number of bits to clock out\n \\return the readback data, numBits-1 is first in"]
    pub fn SoapySDRDevice_transactSPI(
        device: *mut SoapySDRDevice,
        addr: ::std::os::raw::c_int,
        data: ::std::os::raw::c_uint,
        numBits: usize,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Enumerate the available UART devices.\n \\param device a pointer to a device instance\n \\param [out] length the number of UART names\n \\return a list of names of available UARTs"]
    pub fn SoapySDRDevice_listUARTs(
        device: *const SoapySDRDevice,
        length: *mut usize,
    ) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Write data to a UART device.\n Its up to the implementation to set the baud rate,\n carriage return settings, flushing on newline.\n \\param device a pointer to a device instance\n \\param which the name of an available UART\n \\param data a null terminated array of bytes\n \\return 0 for success or error code on failure"]
    pub fn SoapySDRDevice_writeUART(
        device: *mut SoapySDRDevice,
        which: *const ::std::os::raw::c_char,
        data: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read bytes from a UART until timeout or newline.\n Its up to the implementation to set the baud rate,\n carriage return settings, flushing on newline.\n \\param device a pointer to a device instance\n \\param which the name of an available UART\n \\param timeoutUs a timeout in microseconds\n \\return a null terminated array of bytes"]
    pub fn SoapySDRDevice_readUART(
        device: *const SoapySDRDevice,
        which: *const ::std::os::raw::c_char,
        timeoutUs: ::std::os::raw::c_long,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " A handle to the native device used by the driver.\n The implementation may return a null value if it does not support\n or does not wish to provide access to the native handle.\n \\param device a pointer to a device instance\n \\return a handle to the native device or null"]
    pub fn SoapySDRDevice_getNativeDeviceHandle(
        device: *const SoapySDRDevice,
    ) -> *mut ::std::os::raw::c_void;
}
#[doc = "!< A fatal error. The application will most likely terminate. This is the highest priority."]
pub const SoapySDRLogLevel_SOAPY_SDR_FATAL: SoapySDRLogLevel = 1;
#[doc = "!< A critical error. The application might not be able to continue running successfully."]
pub const SoapySDRLogLevel_SOAPY_SDR_CRITICAL: SoapySDRLogLevel = 2;
#[doc = "!< An error. An operation did not complete successfully, but the application as a whole is not affected."]
pub const SoapySDRLogLevel_SOAPY_SDR_ERROR: SoapySDRLogLevel = 3;
#[doc = "!< A warning. An operation completed with an unexpected result."]
pub const SoapySDRLogLevel_SOAPY_SDR_WARNING: SoapySDRLogLevel = 4;
#[doc = "!< A notice, which is an information with just a higher priority."]
pub const SoapySDRLogLevel_SOAPY_SDR_NOTICE: SoapySDRLogLevel = 5;
#[doc = "!< An informational message, usually denoting the successful completion of an operation."]
pub const SoapySDRLogLevel_SOAPY_SDR_INFO: SoapySDRLogLevel = 6;
#[doc = "!< A debugging message."]
pub const SoapySDRLogLevel_SOAPY_SDR_DEBUG: SoapySDRLogLevel = 7;
#[doc = "!< A tracing message. This is the lowest priority."]
pub const SoapySDRLogLevel_SOAPY_SDR_TRACE: SoapySDRLogLevel = 8;
#[doc = "!< Streaming status indicators such as \"U\" (underflow) and \"O\" (overflow)."]
pub const SoapySDRLogLevel_SOAPY_SDR_SSI: SoapySDRLogLevel = 9;
extern "C" {
    #[doc = " Send a message to the registered logger.\n \\param logLevel a possible logging level\n \\param message a logger message string"]
    pub fn SoapySDR_log(logLevel: SoapySDRLogLevel, message: *const ::std::os::raw::c_char);
}
#[doc = " Typedef for the registered log handler function."]
pub type SoapySDRLogHandler = ::std::option::Option<
    unsafe extern "C" fn(logLevel: SoapySDRLogLevel, message: *const ::std::os::raw::c_char),
>;
extern "C" {
    #[doc = " Register a new system log handler.\n Platforms should call this to replace the default stdio handler.\n Passing `NULL` restores the default."]
    pub fn SoapySDR_registerLogHandler(handler: SoapySDRLogHandler);
}
extern "C" {
    #[doc = " Set the log level threshold.\n Log messages with lower priority are dropped."]
    pub fn SoapySDR_setLogLevel(logLevel: SoapySDRLogLevel);
}
extern "C" {
    #[doc = " Get the size of a single element in the specified format.\n \\param format a supported format string\n \\return the size of an element in bytes"]
    pub fn SoapySDR_formatToSize(format: *const ::std::os::raw::c_char) -> usize;
}
extern "C" {
    #[doc = "! Query the root installation path"]
    pub fn SoapySDR_getRootPath() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " The list of paths automatically searched by loadModules().\n \\param [out] length the number of elements in the result.\n \\return a list of automatically searched file paths"]
    pub fn SoapySDR_listSearchPaths(length: *mut usize) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " List all modules found in default path.\n The result is an array of strings owned by the caller.\n \\param [out] length the number of elements in the result.\n \\return a list of file paths to loadable modules"]
    pub fn SoapySDR_listModules(length: *mut usize) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " List all modules found in the given path.\n The result is an array of strings owned by the caller.\n \\param path a directory on the system\n \\param [out] length the number of elements in the result.\n \\return a list of file paths to loadable modules"]
    pub fn SoapySDR_listModulesPath(
        path: *const ::std::os::raw::c_char,
        length: *mut usize,
    ) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Load a single module given its file system path.\n The caller must free the result error string.\n \\param path the path to a specific module file\n \\return an error message, empty on success"]
    pub fn SoapySDR_loadModule(path: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " List all registration loader errors for a given module path.\n The resulting dictionary contains all registry entry names\n provided by the specified module. The value of each entry\n is an error message string or empty on successful load.\n \\param path the path to a specific module file\n \\return a dictionary of registry names to error messages"]
    pub fn SoapySDR_getLoaderResult(path: *const ::std::os::raw::c_char) -> SoapySDRKwargs;
}
extern "C" {
    #[doc = " Get a version string for the specified module.\n Modules may optionally provide version strings.\n \\param path the path to a specific module file\n \\return a version string or empty if no version provided"]
    pub fn SoapySDR_getModuleVersion(
        path: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Unload a module that was loaded with loadModule().\n The caller must free the result error string.\n \\param path the path to a specific module file\n \\return an error message, empty on success"]
    pub fn SoapySDR_unloadModule(
        path: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Load the support modules installed on this system.\n This call will only actually perform the load once.\n Subsequent calls are a NOP."]
    pub fn SoapySDR_loadModules();
}
extern "C" {
    #[doc = " Unload all currently loaded support modules."]
    pub fn SoapySDR_unloadModules();
}
extern "C" {
    #[doc = " Convert a tick count into a time in nanoseconds using the tick rate.\n \\param ticks a integer tick count\n \\param rate the ticks per second\n \\return the time in nanoseconds"]
    pub fn SoapySDR_ticksToTimeNs(
        ticks: ::std::os::raw::c_longlong,
        rate: f64,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " Convert a time in nanoseconds into a tick count using the tick rate.\n \\param timeNs time in nanoseconds\n \\param rate the ticks per second\n \\return the integer tick count"]
    pub fn SoapySDR_timeNsToTicks(
        timeNs: ::std::os::raw::c_longlong,
        rate: f64,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[doc = " Get the SoapySDR library API version as a string.\n The format of the version string is <b>major.minor.increment</b>,\n where the digits are taken directly from <b>SOAPY_SDR_API_VERSION</b>."]
    pub fn SoapySDR_getAPIVersion() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the ABI version string that the library was built against.\n A client can compare <b>SOAPY_SDR_ABI_VERSION</b> to getABIVersion()\n to check for ABI incompatibility before using the library.\n If the values are not equal then the client code was\n compiled against a different ABI than the library."]
    pub fn SoapySDR_getABIVersion() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the library version and build information string.\n The format of the version string is <b>major.minor.patch-buildInfo</b>.\n This function is commonly used to identify the software back-end\n to the user for command-line utilities and graphical applications."]
    pub fn SoapySDR_getLibVersion() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn _rust_wrapper_SoapySDRDevice_setupStream(
        device: *mut SoapySDRDevice,
        out_stream: *mut *mut SoapySDRStream,
        direction: ::std::os::raw::c_int,
        format: *const ::std::os::raw::c_char,
        channels: *const usize,
        numChans: usize,
        args: *const SoapySDRKwargs,
    ) -> ::std::os::raw::c_int;
}

